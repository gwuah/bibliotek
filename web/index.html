<!DOCTYPE html>
<html> 
    <head>
        <title>Bibliotek</title>
        <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    </head>
    <body  style="background-color: white;">
        <h1>Bibliotek</h1>
        <form action="/upload" method="post" enctype="multipart/form-data">
            <input type="file" name="file" multiple>
            <input type="submit" value="Upload">
        </form>
        <div id="progressBar" style="width: 0%; height: 20px; background-color: #ddd;"></div>
        <div id="status"></div>
        <script>
            async function continueUpload(file, options = {}) {
                const { chunkSize, maxConcurrent, onProgress, upload_id } = options;
                const totalChunks = Math.ceil(file.size / chunkSize);
                const uploadUrl = "/upload?state=continue"
                let uploadedChunks = 0;

                const uploadChunk = async (chunk, chunkIndex) => {
                    const formData = new FormData();
                    formData.append("chunk", chunk);
                    formData.append("upload_id", upload_id);

                    const response = await axios.post(uploadUrl, formData, {
                        headers: {
                            "Content-Type": "multipart/form-data",
                        },
                    });

                    onProgress && onProgress({chunkIndex, uploadedChunks, totalChunks});
                    uploadedChunks++;
                    return response.data;
                   
                };

                const chunks = [];
                for (let i = 0; i < totalChunks; i++) {
                    const start = i * chunkSize;
                    const end = Math.min(start + chunkSize, file.size);
                    const chunk = file.slice(start, end);
                    chunks.push({ chunk, index: i});
                }

                const results = [];
                for (let i = 0; i < chunks.length; i += maxConcurrent) {
                    const batch = chunks.slice(i, i + maxConcurrent);
                    const batchPromises = batch.map(({chunk,index}) => uploadChunk(chunk, index));
                    const batchResults = await Promise.all(batchPromises);
                    results.push(...batchResults);
                }

                return results;
            } 
        </script>
        <script>
            const form = document.querySelector('form');
            form.addEventListener('submit', async(e) => {
                e.preventDefault();
                const file = form.elements.file.files[0];
                if (!file) {
                    statusDiv.textContent = 'No file selected';
                    return;
                };

                const uploadId = await initUpload(file.name);
                console.log(uploadId);

                yyy(file, {
                    upload_id: uploadId,
                    chunkSize: 2 * 1024 * 1024, 
                    maxConcurrent: 2,
                    onProgress: (progress) => {
                        progressBar.style.width = `${progress.overallProgress}%`;
                        statusDiv.textContent = `Uploading chunk ${progress.chunkIndex + 1}/${progress.totalChunks} - ${progress.overallProgress}%`;
                    }
                }).then(() => {
                    completeUpload(uploadId);
                    statusDiv.textContent = 'Upload completed!';
                }).catch((error) => {
                    statusDiv.textContent = `Upload failed: ${error.message}`;
                });

                //  try {
                //     await yyy(file, {
                //         chunkSize: 2 * 1024 * 1024, // 2MB chunks
                //         maxConcurrent: 2,
                //         onProgress: (progress) => {
                //             progressBar.style.width = `${progress.overallProgress}%`;
                //             statusDiv.textContent = `Uploading chunk ${progress.chunkIndex + 1}/${progress.totalChunks} - ${progress.overallProgress}%`;
                //         }
                //     });
                // } catch (error) {
                //     statusDiv.textContent = `Upload failed: ${error.message}`;
                // }

                // await completeUpload(uploadId);
                // statusDiv.textContent = 'Upload completed!';
                // const formData = new FormData(form);
                // axios.post('/upload', formData).then(response => {
                //     console.log(response.data);
                // });
            });

            const fileInput = document.getElementById('fileInput');
                const progressBar = document.getElementById('progressBar');
                const statusDiv = document.getElementById('status');

                fileInput.addEventListener('change', async (event) => {
                    const file = event.target.files[0];
                    if (!file) return;

                    try {
                        await uploadFileInChunks(file, {
                            chunkSize: 2 * 1024 * 1024, // 2MB chunks
                            maxConcurrent: 2,
                            onProgress: (progress) => {
                                progressBar.style.width = `${progress.overallProgress}%`;
                                statusDiv.textContent = `Uploading chunk ${progress.chunkIndex + 1}/${progress.totalChunks} - ${progress.overallProgress}%`;
                            }
                        });

                        statusDiv.textContent = 'Upload completed!';
                    } catch (error) {
                        statusDiv.textContent = `Upload failed: ${error.message}`;
                    }
                });
        </script>
        <script>
            async function initUpload(file_name) {
                const formData = new FormData();
                formData.append("file_name", file_name);
                const response = await axios.post("/upload?state=init", formData, {
                    headers: {
                        "Content-Type": "multipart/form-data",
                    },
                });
                return response.data.upload_id;
            }

            async function completeUpload(upload_id) {
                const formData = new FormData();
                formData.append("upload_id", upload_id);
                const response = await axios.post("/upload?state=complete", formData, {
                    headers: {
                        "Content-Type": "multipart/form-data",
                    },
                });
            }
        </script>
        <script>
            async function yyy(file, options = {}) {
                    const { chunkSize, maxConcurrent, onProgress, upload_id } = options;
                    const totalChunks = Math.ceil(file.size / chunkSize);
                    const uploadUrl = "/upload?state=continue";

                    // Track per-chunk bytes loaded
                    const progressBytes = new Array(totalChunks).fill(0);
                    const chunkSizes = new Array(totalChunks).fill(0);
                    const totalBytes = file.size;

                    const report = (chunkIndex) => {
                        const uploadedBytes = progressBytes.reduce((a, b) => a + b, 0);
                        const overallProgress = Math.round((uploadedBytes / totalBytes) * 100);
                        const chunkProgress = Math.round((progressBytes[chunkIndex] / chunkSizes[chunkIndex]) * 100);
                        onProgress && onProgress({
                            chunkIndex,
                            chunkProgress,
                            overallProgress,
                            uploadedBytes,
                            totalBytes,
                            totalChunks,
                        });
                    };

                    const uploadChunk = async (chunk, chunkIndex) => {
                        chunkSizes[chunkIndex] = chunk.size;

                        const formData = new FormData();
                        formData.append("chunk", chunk);
                        formData.append("upload_id", upload_id);
                        // If your backend needs ordering, include the index:
                        // formData.append("index", chunkIndex);

                        const resp = await axios.post(uploadUrl, formData, {
                            headers: { "Content-Type": "multipart/form-data" },
                            onUploadProgress: (e) => {
                                // e.total is the size of THIS chunk
                                // e.loaded may reset for each request; thatâ€™s fine
                                progressBytes[chunkIndex] = Math.min(e.loaded ?? 0, chunk.size);
                                report(chunkIndex);
                            },
                        });

                        // Ensure we mark the chunk fully uploaded even if onUploadProgress was capped/rounded
                        progressBytes[chunkIndex] = chunk.size;
                        report(chunkIndex);
                        return resp.data;
                    };

                    const chunks = [];
                    for (let i = 0; i < totalChunks; i++) {
                        const start = i * chunkSize;
                        const end = Math.min(start + chunkSize, file.size);
                        chunks.push({ chunk: file.slice(start, end), index: i });
                    }

                    const results = [];
                    for (let i = 0; i < chunks.length; i += maxConcurrent) {
                        const batch = chunks.slice(i, i + maxConcurrent);
                        const batchResults = await Promise.all(
                            batch.map(({ chunk, index }) => uploadChunk(chunk, index))
                        );
                        results.push(...batchResults);
                    }

                    return results;
                }

        </script>
    </body>
</html>